/*
1、左值和右值基本概念
   简单归纳：
   用的是对象的值（内容）         右值
   用的是对象的身份（内存的位置） 左值

   赋值运算符、解引用、下标运算符、内置类型均返回左值
   取地址运算符 返回右值（用的是对象的内容）

   decltype：如果表达式的结果是一个左值，decltype作用于该表达式返回的是一个引用类型
   举例：int* p ，decltype(*p)返回的是int& （解引用运算符返回左值）
         int* p ，decltype(&p)返回的是int**（取地址运算符返回右值）

2、前置和后置运算符

   int i = 0;
   int j;
   j = ++i; j = 1 i = 1 首先将运算对象i加1，再将改变后的对象作为求值结果   -- 将对象本身作为左值返回
   j = i++; j = 1 i = 2 也将运算对象i加1，但是返回的是改变之前的值的副本   -- 将对象原始值的副本作为右值返回
   为了提升效率，避免拷贝副本，因此除非必须，否则不要用后置返回的运算符版本

   如何混用解引用与递增运算符？
   *ptr++;
   后置运算符的优先级高于解引用运算符，因此实际为*(ptr++)，ptr++把ptr的值加1，
   然后返回初始值的副本作为运算结果，此时解引用的对象是ptr未增加之前的值
   效果：这条语句输出ptr开始时指向的那个元素，并且将指针向前移动一个位置

3、条件运算符

   condition ? expr1 : expr2;
   condition是判断条件的表达式，expr1和expr2是两个类型相同或者可能转换为某个公共类型的表达式
   应用：首先求condition的值，如果为真就对expr1求值并返回该值，否则对expr2求值并返回该值

4、位运算符

   p136    ~ 位求反
           & 位与
           | 位或
           ^ 位异或 两个运算位有且只有一个为1结果为1 否则为0
           << 左移
           >> 右移
5、sizeof运算符
   返回的是一个size_t类型（返回一个变量名称或一个表达式所占用的字节数）
   sizeof(type)  返回变量类型的大小
   sizeof expr   返回表达式结果的大小

   sizeof p;     返回指针本身所占的空间大小
   sizeof *p;    返回p所指向的类型的空间大小

   对引用类型执行sizeof得到被引用对象所占的内存空间的大小
   对指针执行sizeof得到指针本身所占用的内存空间的大小
   对解引用指针执行sizeof得到指针所指向的对象所占用的内存空间的大小
   对数组执行sizeof得到整个数组所占用的内存空间的大小 注意sizeof运算符不会把数组名当成指针来处理

6、指针转换方式
   常量整数值0和nullptr可以转换成任意指针类型
   指向任意非常量的指针可以转换成void*
   指向任意常量的指针可以转换成const void*

   允许将指向非常量的指针或引用转换成指向常量的指针或者引用
   int i;
   const int &j = i;   非常量转换成const int的引用
   const int* p = &i;  非常量的地址转换成const的地址

7、强制类型转换(cast)
   cast-name<type>(expression);

   cast-name:
   
   (1):static_cast: 任何具有明确定义的类型转换，只要不包含底层const 都可以使用static_cast

   (2)const_cast: 只能改变运算对象的底层const(去掉const的性质 将常量转换成非常量) 不能用这个改变表达式的类型

   (3)dynamic_cast:运行时目标识别技术(RTTI),用于将基类的指针转换成子类的指针
   */